---
- name: Prep_download | Set a few facts
  set_fact:
    download_force_cache: "{{ true if download_run_once else download_force_cache }}"

- name: Download_file | Show url of file to dowload
  debug:
    msg: "{{ download.url }}"
  run_once: "{{ download_run_once }}"

- name: Download_file | Set pathname of cached file
  set_fact:
    file_path_cached: "{{ download_cache_dir }}/{{ download.dest | basename }}"
  tags:
  - facts

- name: Download_file | Create dest directory on node
  file:
    path: "{{ download.dest | dirname }}"
    owner: "{{ download.owner }}"
    mode: 0755
    state: directory
    recurse: yes

- name: Download_file | Create local cache directory
  file:
    path: "{{ file_path_cached | dirname }}"
    state: directory
    recurse: yes
  delegate_to: localhost
  connection: local
  delegate_facts: false
  run_once: true
  become: false
  when:
  - download_force_cache
  tags:
  - localhost

- name: Download_file | Create cache directory on download_delegate host
  file:
    path: "{{ file_path_cached | dirname }}"
    state: directory
    recurse: yes
  delegate_to: "{{ download_delegate }}"
  delegate_facts: false
  run_once: true
  when:
  - download_force_cache
  - not download_localhost

# This must always be called, to check if the checksum matches. On no-match the file is re-downloaded.
# This task will avoid logging it's parameters to not leak environment passwords in the log
- name: Download_file | Download item
  get_url:
    url: "{{ download.url }}"
    dest: "{{ file_path_cached if download_force_cache else download.dest }}"
    owner: "{{ omit if download_localhost else (download.owner) }}"
    mode: "{{ omit if download_localhost else (download.mode) }}"
    checksum: "{{ 'sha256:' + download.sha256 if download.sha256 else omit }}"
    validate_certs: "{{ download_validate_certs }}"
    url_username: "{{ download.username }}"
    url_password: "{{ download.password }}"
    force_basic_auth: "{{ download.force_basic_auth }}"
    timeout: "{{ download.timeout }}"
  delegate_to: "{{ download_delegate if download_force_cache else inventory_hostname }}"
  run_once: "{{ download_force_cache }}"
  register: get_url_result
  become: "{{ not download_localhost }}"
  until: "'OK' in get_url_result.msg or
    'file already exists' in get_url_result.msg or
    get_url_result.status_code | default() == 304"
  retries: "{{ download_retries }}"
  delay: "{{ retry_stagger }}"
  environment: "{{ proxy_env }}"
  no_log: "{{ not (unsafe_show_logs | bool) }}"

- name: Download_file | Copy file back to ansible host file cache
  ansible.posix.synchronize:
    src: "{{ file_path_cached }}"
    dest: "{{ file_path_cached }}"
    use_ssh_args: true
    mode: pull
  when:
  - download_force_cache
  - not download_localhost
  - download_delegate == inventory_hostname

- name: Download_file | Copy file from cache to nodes, if it is available
  ansible.posix.synchronize:
    src: "{{ file_path_cached }}"
    dest: "{{ download.dest }}"
    use_ssh_args: true
    mode: push
  register: get_task
  until: get_task is succeeded
  delay: "{{ retry_stagger | random + 3 }}"
  retries: "{{ download_retries }}"
  when:
  - download_force_cache

- name: Download_file | Set mode and owner
  file:
    path: "{{ download.dest }}"
    mode: "{{ download.mode }}"
    owner: "{{ download.owner }}"
  when:
  - download_force_cache

- name: Extract_file | Unpacking archive
  unarchive:
    src: "{{ download.dest }}"
    dest: "{{ download.dest | dirname }}"
    owner: "{{ download.owner }}"
    mode: "{{ download.mode }}"
    copy: no
    extra_opts: "{{ download.unarchive_extra_opts }}"
  when:
  - download.unarchive
